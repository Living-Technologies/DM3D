#!/usr/bin/env python3

###
# #%L
# Triangulated surface for deforming in 3D.
# %%
# Copyright (C) 2013 - 2023 University College London
# %%
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
# #L%
###

import struct

from .meshdata import Track, Mesh

class MeshReader:
    """
        Class for reading meshes from a collection of bytes. This class
        could be considered private. It is used by the function
        'loadMeshTracks.
        
        The readXyz methods are intented to read the corresponding 
        java DataOutputStream written values.
    """
    def __init__(self, data):
        """
            Starts a reader over the provided bytes.
            Args:
                data: bytes-like object with mesh tracks. Will be used 
                      with struct.unpack_from.
        """
        self.bytes = data
        self.pos = 0
        self.tracks = []
    def load(self):
        """
            Populates and the list of tracks for this reader. 
        """
        self.version = self.readInt()
        self.track_count = self.readInt()
        for i in range(self.track_count):
            name = self.readUTFString();
            track = Track(name)
            mesh_count = self.readInt()
            for j in range(mesh_count):
                frame = self.readInt()
                position_count = self.readInt()
                positions = self.readDoubles(position_count)
                connection_count = self.readInt()
                connections = self.readInts(connection_count)
                triangle_count = self.readInt()
                triangles = self.readInts(triangle_count)
                track.addMesh(frame, Mesh(positions, connections, triangles))
            self.tracks.append(track)
            
                
    def readInt(self):
        """
            Reads a single 4 byte int big endian.
        """
        i = struct.unpack_from(">i", self.bytes, self.pos)[0]
        self.pos += 4
        return i
    
    def readInts(self, n):
        """
            Reads n 4 byte big-endian ints.
        """
        ints = struct.unpack_from(">%si"%n, self.bytes, self.pos)
        self.pos += 4*n
        return ints
        
    def readDouble(self):
        """
            Resuts a single 8 byte floating point value, big endian.
        """
        d = struct.unpack_from(">d", self.bytes, self.pos)[0]
        self.pos+=8
        return d
    
    def readDoubles(self, n):
        """
            Reads n 8 byte floating point values, big endian.
            Args:
                n: number of floats to read.
        """
        doubles = struct.unpack_from(">%sd"%n, self.bytes, self.pos)
        self.pos += n*8
        return doubles
        
    def readUTFString(self):
        """
            Reads a utf string, the first 2 bytes are a big endian
            short that represents the number of characters. Then it 
            reads that many bytes/characters.
        """
        s = struct.unpack_from(">h", self.bytes, self.pos)[0]
        self.pos += 2
        name = struct.unpack_from("%ss"%s, self.bytes, self.pos)[0]
        self.pos += s
        return name.decode("utf-8")
    def getTracks(self):
        """
            returns the generated tracks, should be called after load.
        """
        return self.tracks

def loadMeshTracks(filename):
    """
      For opening mesh files generated by our Deformable Mesh plugin.
      Args:
        filename: a str to be used with open.
    """
    with open(filename, 'rb') as f:
        data = f.read()
        reader = MeshReader(data)
        reader.load()
        return reader.tracks
    return None

    

if __name__=="__main__":
    import sys
    print("testing purposes only")
    tracks = loadMeshTracks(sys.argv[1])
    print("%d tracks loaded"%len(tracks))
    for track in tracks:
        print("%s:"%track.name)
        meshes = track.meshes
        for mesh in meshes:
            print("\tframe: %s with %d positions, %d connections, %d triangles"%(mesh, len(meshes[mesh].positions), len(meshes[mesh].connections), len(meshes[mesh].triangles)))

    
